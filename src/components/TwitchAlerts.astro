---
import "@speed-highlight/core/themes/dark.css";
---

<div
    id="twitch-alerts"
    class="fixed inset-0 flex justify-end min-h-screen items-end"
>
    <div class="w-full hidden" id="alert-container">
        <div class="alert__text">
            <code
                class="shj-lang-js rounded-md !text-xl alert__text__message hidden !py-4 !px-4 !font-cascadia break-words whitespace-pre-wrap"
            ></code>
        </div>
    </div>
</div>

<script>
    import { highlightAll } from "@speed-highlight/core";
    import {
        extractSocketTokenFromHead,
        createStreamLabsSocket,
    } from "@/lib/Twitch";
    import {
        ALERTS,
        type Alert,
        type AlertVariant,
    } from "@/lib/TwitchAlertVariants.ts";
    import confetti from "canvas-confetti";
    import { handleStreamLabsEvent } from "@/lib/handle-streamlabs-event";

    const slabsSocketToken = extractSocketTokenFromHead();
    const slabsSocket = createStreamLabsSocket({ token: slabsSocketToken });

    const TIME_BETWEEN_ALERTS = 5000;
    let isProcessingQueue = false;
    let currentAlert: Alert | null = null;
    const alertQueue: Alert[] = [];
    const $alertContainer = document.getElementById(
        "alert-container",
    ) as HTMLDivElement;
    const $alertMessage = document.querySelector(
        ".alert__text__message",
    ) as HTMLParagraphElement;

    const sleep = (ms: number) =>
        new Promise((resolve) => setTimeout(resolve, ms));

    const addAlert = (
        type: Alert["type"],
        variables: Record<string, string | number>,
    ) => {
        if (type === "host") {
            /* Host are not more available in Twitch, so treat them as raids */
            type = "raid";
        }
        const alert = ALERTS[type];
        if (!alert) {
            console.error(`Alert type ${type} not defined in ALERTS`);
            return;
        }

        if (!alert.variants) {
            console.error(`Alert type ${type} has no variants`);
            return;
        }

        alertQueue.push({ type, variants: alert.variants, variables });
        if (!isProcessingQueue) processAlertQueue();
    };

    async function showAlert(alert: Alert) {
        const { type, variants, variables } = alert;
        const applicableVariants = variants.filter(
            (variant) =>
                type !== "cheer" ||
                (variant.minBits as number) <=
                    ((variables?.bits as number) ?? 0),
        );
        const variant = applicableVariants.reduce(
            (highest: AlertVariant | null, current: AlertVariant) =>
                !highest || (current.minBits ?? 0) > (highest.minBits ?? 0)
                    ? current
                    : highest,
            null,
        );

        if (!variant) {
            console.error("No variant found for alert", alert);
            return 0;
        }

        const replaceVariables = (template: string) => {
            const CHARACTERS_PER_LINE = 50;

            // Función para dividir el texto en líneas cada CHARACTERS_PER_LINE caracteres
            const insertLineBreaks = (text: string) => {
                let result = "";
                if (text.length <= CHARACTERS_PER_LINE) return text;
                for (let i = 0; i < text.length; i += CHARACTERS_PER_LINE) {
                    result += text.slice(i, i + CHARACTERS_PER_LINE) + "\n";
                }
                return result;
            };

            return !variables
                ? template
                : Object.entries(variables).reduce(
                      (str, [key, value]) =>
                          str.replace(
                              new RegExp(`\\$${key}`, "g"),
                              key === "message"
                                  ? insertLineBreaks(value.toString() ?? "")
                                  : value?.toString(),
                          ),
                      template,
                  );
        };

        if (variant.audioSrc) {
            const audio = new Audio(variant.audioSrc);
            audio.volume = variant.volume ?? 1;
            audio.onended = () => {
                if (variant.enableTTS && variables?.message) {
                    sleep(1000).then(() =>
                        playWithStreamElements(variables.message as string),
                    );
                }
            };
            audio.play();
        } else if (variant.enableTTS && variables?.message) {
            playWithStreamElements(variables.message as string);
        }

        $alertMessage.innerHTML = replaceVariables(
            variant.messageTemplate ?? "",
        );

        $alertMessage.classList.toggle("hidden", !variant.messageTemplate);
        await highlightAll({ hideLineNumbers: false }); // Highlight code blocks

        /* Mostrar alerta */
        $alertContainer.classList.remove("hidden", "animate-fade-out-down");
        $alertContainer.classList.add("animate-fade-in-up");

        if (variant.effect === "confetti")
            confetti({ particleCount: 100, spread: 70, origin: { y: 1 } });

        const duration = variant.duration ?? 5000;

        await sleep(duration);

        /* Ocultar alerta */
        $alertContainer.classList.remove("animate-fade-in-up");
        $alertContainer.classList.add("animate-fade-out-down");

        await sleep(500);

        $alertContainer.classList.add("hidden");
    }

    const skipAlert = () => {
        // Hide the alert
        $alertContainer.classList.remove("animate-fade-in-up");
        $alertContainer.classList.add("animate-fade-out-down");
        // Wait for the animation to finish
        sleep(500).then(() => {
            $alertContainer.classList.add("hidden");
        });
        currentAlert = null;
    };

    async function processAlertQueue() {
        isProcessingQueue = true;
        while (alertQueue.length > 0) {
            currentAlert = alertQueue.shift() ?? null;
            if (currentAlert) {
                await showAlert(currentAlert);
                await sleep(TIME_BETWEEN_ALERTS);
            }
        }
        isProcessingQueue = false;
    }

    const playWithStreamElements = (text: string) => {
        const audio = new Audio(
            `https://api.streamelements.com/kappa/v2/speech?voice=Enrique&text=${text}`,
        );
        audio.volume = 0.5;
        audio.play();
    };

    slabsSocket.on("connect", () => console.log("Connected to StreamLabs"));
    slabsSocket.on("event", (event: any) => {
        handleStreamLabsEvent({ event, addAlert, skipAlert });
    });
</script>
